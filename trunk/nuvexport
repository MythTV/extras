#!/usr/bin/perl -w
# Last Updated: 2005.01.26 (xris)

# Autoflush buffers
    $|++;

# Set up the signal handlers
    BEGIN {
        $SIG{'INT'}  = sub { print "\n"; exit; };
        $SIG{'QUIT'} = sub { print "\n"; exit; };
    # Annoy people running as root
        if ($< < 1) {
            print "You are running nuvexport as root -- this is not advised.\nPress ENTER if you really want to do this.\n";
            <STDIN>;
        }
    }

# Add a couple of include paths so we can load the various export and gui modules
    use File::Basename;
    use lib dirname($ENV{'_'}), '/usr/share/nuvexport', '/usr/local/share/nuvexport';

# How was nuvexport called?
    my $callname = $0;

# Load the myth and nuv utilities, and connect to the database
    use nuv_export::shared_utils;

# Make sure that we have mythtranscode installed
    $Prog{'mythtranscode'} = find_program('mythtranscode');
    die "You need mythtranscode in order to use nuvexport.\n\n" unless ($Prog{'mythtranscode'});

# Make sure that we have nice installed
    $Prog{'nice'} = find_program('nice');
    die "You need nice in order to use nuvexport.\n\n" unless ($Prog{'nice'});

# Load the recordings, and the $video_dir variable
    use mythtv::recordings;

# Decipher --ffmpeg/--transcode.  default is --ffmpeg

    my $export_prog = 'ffmpeg';

    use Getopt::Long qw(:config pass_through);

    GetOptions( 'ffmpeg' => sub { $export_prog = 'ffmpeg' },
                'transcode' => sub { $export_prog = 'transcode' } );

    # Load the exporters based on which suite was selected above
    if( $export_prog eq 'transcode' ) {
        # Transcode - doesn't seem to work for many MPEG recordings
        use export::transcode::XviD;
            push @Exporters, export::transcode::XviD->new;
        use export::transcode::SVCD;
            push @Exporters, export::transcode::SVCD->new;
        use export::transcode::VCD;
            push @Exporters, export::transcode::VCD->new;
        use export::transcode::DVCD;
            push @Exporters, export::transcode::DVCD->new;
        use export::transcode::DVD;
            push @Exporters, export::transcode::DVD->new;
    } elsif ( $export_prog eq 'ffmpeg' ) {
        # Ffmpeg - seems to work better and is the default
        use export::ffmpeg::XviD;
            push @Exporters, export::ffmpeg::XviD->new;
        use export::ffmpeg::SVCD;
            push @Exporters, export::ffmpeg::SVCD->new;
        use export::ffmpeg::VCD;
            push @Exporters, export::ffmpeg::VCD->new;
        use export::ffmpeg::DVCD;
            push @Exporters, export::ffmpeg::DVCD->new;
        use export::ffmpeg::DVD;
            push @Exporters, export::ffmpeg::DVD->new;
        use export::ffmpeg::DivX;
            push @Exporters, export::ffmpeg::DivX->new;
        use export::ffmpeg::ASF;
            push @Exporters, export::ffmpeg::ASF->new;
        use export::ffmpeg::MP3;
            push @Exporters, export::ffmpeg::MP3->new;
    }

# Load the other export modules
    use export::MPEG2_cut;
        push @Exporters, export::MPEG2_cut->new;
    use export::NUV_SQL;
        push @Exporters, export::NUV_SQL->new;

# Load the ui
    use nuv_export::ui;
    load_cli_args();

# Import a callname?
    if (!$Args{'mode'} && $callname =~ /^.*?nuvexport-(\S+)$/) {
        $Args{'mode'} = $1;
    }

# No server stuff enabled yet
    $Args{'noserver'} = 1;

# Print the help - for now, this is just perldoc
    if ($Args{'help'}) {
        print "Help section still needs to be updated\n";
        exec("perldoc $0");
    }

# Load episodes from the commandline (and display/quit if this is search-only)
    my @episodes = load_cli_episodes();

# Which exporter to use
    my $exporter = query_exporters($export_prog);

# Gather the episodes we want to transcode (unless we have them from the cli already)
    @episodes = &load_episodes(@episodes) unless ($is_cli);

# Gather data for this exporter
    $exporter->gather_settings();

# Encode right here?
    if ($Args{'noserver'}) {
        foreach my $episode (@episodes) {
        # Keep track of when we started
            if ($DEBUG) {
                print "\n--------------------------------",
                      "\nTo encode:  ", $episode->{'show_name'};
                print ':  ', $episode->{'title'} if ($episode->{'title'});
                print "\nUse the following commands:\n";
            }
            else {
                print "\nNow encoding:  ", $episode->{'show_name'};
                print ':  ', $episode->{'title'} if ($episode->{'title'});
                print "\nEncode started:  ".localtime()."\n";
            }
            my $start = time();
        # Encode
            $exporter->export($episode);
        # Remove tmpfiles
            wipe_tmpfiles();
        # Report how long the encode lasted
            print "\nEncode finished:  ".localtime()."\n" unless ($DEBUG);
            my $seconds = time() - $start;
            my $timestr = '';
        # How many hours?
            my $hours = int($seconds / 3600);
            $timestr .= $hours.'h ' if ($hours > 0);
            $seconds  = $seconds % 3600;
        # Minutes
            my $minutes = int($seconds / 60);
            $timestr .= $minutes.'m ' if ($minutes > 0);
            $seconds  = $seconds % 60;
        # Generate a nice
            $timestr .= $seconds.'s' if ($seconds > 0 || $timestr eq '');
        # Notify the user
            print "Encode lasted: $timestr\n" unless ($DEBUG);
        }
    }
# Store in the DB
    else {
    }

# Exit gracefully
    exit;


# vim:ts=4:sw=4:ai:et:si:sts=4
